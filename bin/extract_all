#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

function main() {
  const currentDir = process.cwd();
  const docsDir = path.join(currentDir, 'docs');
  const verseDir = path.join(currentDir, 'verse');

  // Check if docs directory exists
  if (!fs.existsSync(docsDir)) {
    console.error('Error: docs directory not found in current directory');
    process.exit(1);
  }

  // Create verse directory if it doesn't exist
  if (!fs.existsSync(verseDir)) {
    fs.mkdirSync(verseDir);
    console.log('Created verse directory');
  }

  // Find all markdown files in docs directory
  const markdownFiles = findMarkdownFiles(docsDir);

  if (markdownFiles.length === 0) {
    console.log('No markdown files found in docs directory');
    return;
  }

  console.log(`Found ${markdownFiles.length} markdown file(s)\n`);

  // Get the path to the extract script
  const extractScript = path.join(__dirname, 'extract');

  // Process each markdown file
  markdownFiles.forEach(file => {
    console.log(`Processing: ${path.relative(currentDir, file)}`);
    // on windows the child process must explicitly call node because we
    // cannot rely on the hashbang
    const onWindows = process.platform === "win32"
    const execCommand = onWindows
          ? `node.exe "${extractScript}" "${file}" -t "${verseDir}"`
          : `"${extractScript}" "${file}" -t "${verseDir}"`;
    try {
      execSync(execCommand, {
        stdio: 'inherit',
        encoding: 'utf-8'
      });
    } catch (error) {
      console.error(`Error processing ${file}: ${error.message}`);
    }
    console.log('');
  });

  // Clean up empty directories in verse
  console.log('Checking for empty directories...');
  cleanEmptyDirectories(verseDir);
}

function findMarkdownFiles(dir) {
  let results = [];
  const items = fs.readdirSync(dir);

  items.forEach(item => {
    // Skip hidden files and symlinks
    if (item.startsWith('.')) {
      return;
    }

    const fullPath = path.join(dir, item);

    try {
      const stat = fs.statSync(fullPath);

      if (stat.isDirectory()) {
        results = results.concat(findMarkdownFiles(fullPath));
      } else if (stat.isFile() && (item.endsWith('.md') || item.endsWith('.markdown'))) {
        results.push(fullPath);
      }
    } catch (err) {
      // Skip files that can't be accessed (broken symlinks, etc.)
      console.warn(`Skipping ${fullPath}: ${err.message}`);
    }
  });

  return results;
}

function cleanEmptyDirectories(dir) {
  if (!fs.existsSync(dir)) {
    return;
  }

  const items = fs.readdirSync(dir);

  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      const contents = fs.readdirSync(fullPath);
      if (contents.length === 0) {
        fs.rmdirSync(fullPath);
        console.log(`Deleted empty directory: ${path.relative(process.cwd(), fullPath)}`);
      }
    }
  });
}

main();
